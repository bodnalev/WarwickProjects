

# This file was *autogenerated* from the file stability_C5-.sage
from sage.all_cmdline import *   # import sage library

_sage_const_2 = Integer(2); _sage_const_0 = Integer(0); _sage_const_1 = Integer(1); _sage_const_3 = Integer(3); _sage_const_6 = Integer(6); _sage_const_4 = Integer(4); _sage_const_5 = Integer(5)
from sage.algebras.flag_algebras import *

def test_identify(n, ftype_points, edges, C0, C1, C2):
    return colored_identify(_sage_const_2 , [[_sage_const_0 ], [_sage_const_1 , _sage_const_2 ]], n, ftype_points, edges=edges, C0=C0, C1=C1, C2=C2)

def test_generate(n):
    return colored_generate(_sage_const_2 , [[_sage_const_0 ], [_sage_const_1 , _sage_const_2 ]], n)

TT = CombinatorialTheory("12ColGraph", test_generate, test_identify, edges=_sage_const_2 , C0=_sage_const_1 , C1=_sage_const_1 , C2=_sage_const_1 )

# Exclude triangles inside parts
f = TT.generate_flags(_sage_const_3 )
TT.exclude(f[-_sage_const_6 :])

# Exclude disjoint edges
f = TT.generate_flags(_sage_const_3 )
avoid = []
for ff in f:
    if len(ff.blocks()['edges']) != _sage_const_2 :
        continue
    yep = True
    for edge in ff.blocks()['edges']:
        for i in range(_sage_const_0 , _sage_const_3 ):
            if [edge[_sage_const_0 ]] in ff.blocks()['C'+str(i)] and [edge[_sage_const_1 ]] in ff.blocks()['C'+str(i)]:
                yep = False
    if not yep:
        continue
    if ff.blocks()['C0'] == [] or ff.blocks()['C1'] == [] or ff.blocks()['C2'] == []:
        continue
    avoid.append(ff)
TT.exclude(avoid)
f = TT.generate_flags(_sage_const_4 )
avoid = []
for ff in f:
    if len(ff.blocks()['edges']) != _sage_const_2 :
        continue
    yep = True
    for edge in ff.blocks()['edges']:
        for i in range(_sage_const_0 , _sage_const_3 ):
            if [edge[_sage_const_0 ]] in ff.blocks()['C'+str(i)] and [edge[_sage_const_1 ]] in ff.blocks()['C'+str(i)]:
                yep = False
    if not yep:
        continue
    if ff.blocks()['C0'] == [] or ff.blocks()['C1'] == [] or ff.blocks()['C2'] == []:
        continue
    if ff.blocks()['edges'] != [[_sage_const_0 , _sage_const_2 ], [_sage_const_1 , _sage_const_3 ]]:
        continue
    avoid.append(ff)
TT.exclude(avoid)

# Exclude special paths
f = TT.generate_flags(_sage_const_4 )
avoid = []
for ff in f:
    if len(ff.blocks()['edges']) != _sage_const_3 :
        continue
    degree = [_sage_const_0 , _sage_const_0 , _sage_const_0 , _sage_const_0 ]
    for edge in ff.blocks()['edges']:
        for v in edge:
            degree[v] += _sage_const_1 
    if sorted(degree) != [_sage_const_1 , _sage_const_1 , _sage_const_2 , _sage_const_2 ]:
        continue
    if ff.blocks()['C0'] == [] or ff.blocks()['C1'] == [] or ff.blocks()['C2'] == []:
        continue
    avoid.append(ff)
TT.exclude(avoid)

# Assumptions
edge_12 = TT.generate_flags(_sage_const_2 )[-_sage_const_1 ]
edge_01 = TT.generate_flags(_sage_const_2 )[_sage_const_5 ]
positives = [edge_12 - edge_01]

# Missing edges
M = _sage_const_1  + edge_12 - _sage_const_1 

# Bad edges
f = TT.generate_flags(_sage_const_2 )[-_sage_const_4 :-_sage_const_1 ]
B = _sage_const_1 
for ff in f:
    B += ff
B -= _sage_const_1 

# Optimize
x = TT.optimize(B - M, _sage_const_6 , maximize=False, positives=positives)
print(x)

