

# This file was *autogenerated* from the file stability_C5-.sage
from sage.all_cmdline import *   # import sage library

_sage_const_2 = Integer(2); _sage_const_0 = Integer(0); _sage_const_1 = Integer(1); _sage_const_3 = Integer(3); _sage_const_6 = Integer(6); _sage_const_4 = Integer(4); _sage_const_5 = Integer(5)
from sage.algebras.flag_algebras import *

def test_identify(n, ftype_points, edges, C0, C1, C2):
    return colored_identify(_sage_const_2 , [[_sage_const_0 ], [_sage_const_1 , _sage_const_2 ]], n, ftype_points, edges=edges, C0=C0, C1=C1, C2=C2)

def test_generate(n):
    return colored_generate(_sage_const_2 , [[_sage_const_0 ], [_sage_const_1 , _sage_const_2 ]], n)

TT = CombinatorialTheory("12ColGraph", test_generate, test_identify, edges=_sage_const_2 , C0=_sage_const_1 , C1=_sage_const_1 , C2=_sage_const_1 )

# Exclude triangles 6.1.6 (1)
f = TT.generate_flags(_sage_const_3 )
TT.exclude(f[-_sage_const_6 :])

# Exclude disjoint edges 6.1.6 (3)
# The edges share a vertex
avoid = [
    TT(_sage_const_3 , edges=[[_sage_const_0 , _sage_const_2 ], [_sage_const_1 , _sage_const_2 ]], C0=[[_sage_const_0 ]], C1=[[_sage_const_1 ]], C2=[[_sage_const_2 ]]),
    TT(_sage_const_3 , edges=[[_sage_const_0 , _sage_const_2 ], [_sage_const_1 , _sage_const_2 ]], C0=[[_sage_const_2 ]], C1=[[_sage_const_0 ]], C2=[[_sage_const_1 ]])
    ]
TT.exclude(avoid)
# The edges are vertex disjoint
avoid = [
    TT(_sage_const_4 , edges=[[_sage_const_0 , _sage_const_2 ], [_sage_const_1 , _sage_const_3 ]], C0=[[_sage_const_0 ], [_sage_const_1 ]], C1=[[_sage_const_2 ]], C2=[[_sage_const_3 ]]),
    TT(_sage_const_4 , edges=[[_sage_const_0 , _sage_const_2 ], [_sage_const_1 , _sage_const_3 ]], C0=[[_sage_const_0 ]], C1=[[_sage_const_1 ], [_sage_const_2 ]], C2=[[_sage_const_3 ]])
    ]
TT.exclude(avoid)

# Exclude special paths 6.1.6 (2)
f = TT.generate_flags(_sage_const_4 )
avoid = []
for ff in f:
    if len(ff.blocks()['edges']) != _sage_const_3 :
        continue
    degree = [_sage_const_0 , _sage_const_0 , _sage_const_0 , _sage_const_0 ]
    for edge in ff.blocks()['edges']:
        for v in edge:
            degree[v] += _sage_const_1 
    if sorted(degree) != [_sage_const_1 , _sage_const_1 , _sage_const_2 , _sage_const_2 ]:
        continue
    if ff.blocks()['C0'] == [] or ff.blocks()['C1'] == [] or ff.blocks()['C2'] == []:
        continue
    avoid.append(ff)
    # print(ff)
TT.exclude(avoid)

# Assumptions
edge_12 = TT(_sage_const_2 , edges=[[_sage_const_0 , _sage_const_1 ]], C0=[], C1=[[_sage_const_0 ]], C2=[[_sage_const_1 ]])
edge_01 = TT(_sage_const_2 , edges=[[_sage_const_0 , _sage_const_1 ]], C0=[[_sage_const_0 ]], C1=[[_sage_const_1 ]], C2=[])
positives = [edge_12 - edge_01]

# Missing edges (correct?)
M = _sage_const_1  + edge_12 - _sage_const_1 

# Bad edges (correct?)
B = _sage_const_1 
B += TT(_sage_const_2 , edges=[[_sage_const_0 , _sage_const_1 ]], C0=[[_sage_const_0 ], [_sage_const_1 ]], C1=[], C2=[])
B += TT(_sage_const_2 , edges=[[_sage_const_0 , _sage_const_1 ]], C0=[[_sage_const_0 ]], C1=[[_sage_const_1 ]], C2=[])
B += TT(_sage_const_2 , edges=[[_sage_const_0 , _sage_const_1 ]], C0=[], C1=[[_sage_const_0 ], [_sage_const_1 ]], C2=[])
B -= _sage_const_1 

# print(M + B)

# Optimize (correct?)
x = TT.optimize(B - M, _sage_const_5 , maximize=False, positives=positives)
print(x)

