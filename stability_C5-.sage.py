

# This file was *autogenerated* from the file stability_C5-.sage
from sage.all_cmdline import *   # import sage library

_sage_const_2 = Integer(2); _sage_const_0 = Integer(0); _sage_const_1 = Integer(1); _sage_const_3 = Integer(3); _sage_const_4 = Integer(4); _sage_const_9 = Integer(9); _sage_const_5 = Integer(5)
from sage.algebras.flag_algebras import *

def test_identify(n, ftype_points, edges, C0, C1, C2):
    return colored_identify(_sage_const_2 , [[_sage_const_0 ], [_sage_const_1 , _sage_const_2 ]], n, ftype_points, edges=edges, C0=C0, C1=C1, C2=C2)

def test_generate(n):
    return colored_generate(_sage_const_2 , [[_sage_const_0 ], [_sage_const_1 , _sage_const_2 ]], n)

TT = CombinatorialTheory("12ColGraph", test_generate, test_identify, edges=_sage_const_2 , C0=_sage_const_1 , C1=_sage_const_1 , C2=_sage_const_1 )

# Exclude triangles 6.1.6 (1)
# f = TT.generate_flags(3)
# exclude = list(f[-6:])
exclude = []
exclude += [
    # TT(3, edges=[[0, 1], [0, 2], [1, 2]], C0=[[0], [1], [2]], C1=[], C2=[]),
    # TT(3, edges=[[0, 1], [0, 2], [1, 2]], C0=[[0], [1]], C1=[[2]], C2=[]),
    # TT(3, edges=[[0, 1], [0, 2], [1, 2]], C0=[[0]], C1=[[1], [2]], C2=[]),
    TT(_sage_const_3 , edges=[[_sage_const_0 , _sage_const_1 ], [_sage_const_0 , _sage_const_2 ], [_sage_const_1 , _sage_const_2 ]], C0=[[_sage_const_0 ]], C1=[[_sage_const_1 ]], C2=[[_sage_const_2 ]]),
    # TT(3, edges=[[0, 1], [0, 2], [1, 2]], C0=[], C1=[[0], [1], [2]], C2=[]),
    # TT(3, edges=[[0, 1], [0, 2], [1, 2]], C0=[], C1=[[0], [1]], C2=[[2]])
]

# Exclude disjoint edges 6.1.6 (3)
# The edges share a vertex
exclude += [
    TT(_sage_const_3 , edges=[[_sage_const_0 , _sage_const_2 ], [_sage_const_1 , _sage_const_2 ]], C0=[[_sage_const_0 ]], C1=[[_sage_const_1 ]], C2=[[_sage_const_2 ]]),
    TT(_sage_const_3 , edges=[[_sage_const_0 , _sage_const_2 ], [_sage_const_1 , _sage_const_2 ]], C0=[[_sage_const_2 ]], C1=[[_sage_const_0 ]], C2=[[_sage_const_1 ]])
    ]
# The edges are vertex disjoint
exclude += [
    TT(_sage_const_4 , edges=[[_sage_const_0 , _sage_const_2 ], [_sage_const_1 , _sage_const_3 ]], C0=[[_sage_const_0 ], [_sage_const_1 ]], C1=[[_sage_const_2 ]], C2=[[_sage_const_3 ]]),
    TT(_sage_const_4 , edges=[[_sage_const_0 , _sage_const_2 ], [_sage_const_1 , _sage_const_3 ]], C0=[[_sage_const_0 ]], C1=[[_sage_const_1 ], [_sage_const_2 ]], C2=[[_sage_const_3 ]])
    ]
TT.exclude(exclude)

# Exclude special paths 6.1.6 (2)
f = TT.generate_flags(_sage_const_4 )
for ff in f:
    if len(ff.blocks()['edges']) != _sage_const_3 :
        continue
    degree = [_sage_const_0 , _sage_const_0 , _sage_const_0 , _sage_const_0 ]
    for edge in ff.blocks()['edges']:
        for v in edge:
            degree[v] += _sage_const_1 
    if sorted(degree) != [_sage_const_1 , _sage_const_1 , _sage_const_2 , _sage_const_2 ]:
        continue
    if ff.blocks()['C0'] == [] or ff.blocks()['C1'] == [] or ff.blocks()['C2'] == []:
        continue
    pas = True
    for i in range(_sage_const_4 ):
        for j in range(i + _sage_const_1 , _sage_const_4 ):
            if degree[i] == degree[j] == _sage_const_1  and (([i] in ff.blocks()['C0'] and [j] in ff.blocks()['C0']) or ([i] in ff.blocks()['C1'] and [j] in ff.blocks()['C1']) or ([i] in ff.blocks()['C2'] and [j] in ff.blocks()['C2'])):
                pas = False
    if not pas:
        continue
    # exclude.append(ff)
    # print(ff)
exclude += [
    TT(_sage_const_4 , edges=[[_sage_const_0 , _sage_const_2 ], [_sage_const_0 , _sage_const_3 ], [_sage_const_1 , _sage_const_3 ]], C0=[[_sage_const_0 ], [_sage_const_3 ]], C1=[[_sage_const_1 ]], C2=[[_sage_const_2 ]]),
    TT(_sage_const_4 , edges=[[_sage_const_0 , _sage_const_2 ], [_sage_const_0 , _sage_const_3 ], [_sage_const_1 , _sage_const_3 ], [_sage_const_0 , _sage_const_1 ], [_sage_const_3 , _sage_const_2 ]], C0=[[_sage_const_0 ], [_sage_const_3 ]], C1=[[_sage_const_1 ]], C2=[[_sage_const_2 ]]),
    TT(_sage_const_4 , edges=[[_sage_const_0 , _sage_const_2 ], [_sage_const_0 , _sage_const_3 ], [_sage_const_1 , _sage_const_3 ], [_sage_const_0 , _sage_const_1 ]], C0=[[_sage_const_0 ], [_sage_const_3 ]], C1=[[_sage_const_1 ]], C2=[[_sage_const_2 ]]),
    TT(_sage_const_4 , edges=[[_sage_const_0 , _sage_const_2 ], [_sage_const_0 , _sage_const_3 ], [_sage_const_1 , _sage_const_3 ], [_sage_const_3 , _sage_const_2 ]], C0=[[_sage_const_0 ], [_sage_const_3 ]], C1=[[_sage_const_1 ]], C2=[[_sage_const_2 ]]),
    
    TT(_sage_const_4 , edges=[[_sage_const_0 , _sage_const_2 ], [_sage_const_0 , _sage_const_3 ], [_sage_const_1 , _sage_const_3 ]], C0=[[_sage_const_1 ]], C1=[[_sage_const_0 ], [_sage_const_3 ]], C2=[[_sage_const_2 ]]),
    TT(_sage_const_4 , edges=[[_sage_const_0 , _sage_const_2 ], [_sage_const_0 , _sage_const_3 ], [_sage_const_1 , _sage_const_3 ], [_sage_const_0 , _sage_const_1 ], [_sage_const_3 , _sage_const_2 ]], C0=[[_sage_const_1 ]], C1=[[_sage_const_0 ], [_sage_const_3 ]], C2=[[_sage_const_2 ]]),
    TT(_sage_const_4 , edges=[[_sage_const_0 , _sage_const_2 ], [_sage_const_0 , _sage_const_3 ], [_sage_const_1 , _sage_const_3 ], [_sage_const_0 , _sage_const_1 ]], C0=[[_sage_const_1 ]], C1=[[_sage_const_0 ], [_sage_const_3 ]], C2=[[_sage_const_2 ]]),
    TT(_sage_const_4 , edges=[[_sage_const_0 , _sage_const_2 ], [_sage_const_0 , _sage_const_3 ], [_sage_const_1 , _sage_const_3 ], [_sage_const_3 , _sage_const_2 ]], C0=[[_sage_const_1 ]], C1=[[_sage_const_0 ], [_sage_const_3 ]], C2=[[_sage_const_2 ]]),
]
TT.exclude(exclude)

# Assumptions
edge_12 = TT(_sage_const_2 , edges=[[_sage_const_0 , _sage_const_1 ]], C0=[], C1=[[_sage_const_0 ]], C2=[[_sage_const_1 ]])
edge_01 = TT(_sage_const_2 , edges=[[_sage_const_0 , _sage_const_1 ]], C0=[[_sage_const_0 ]], C1=[[_sage_const_1 ]], C2=[])
pairs_12 = TT(_sage_const_2 , edges=[[_sage_const_0 , _sage_const_1 ]], C0=[], C1=[[_sage_const_0 ]], C2=[[_sage_const_1 ]]) + TT(_sage_const_2 , edges=[], C0=[], C1=[[_sage_const_0 ]], C2=[[_sage_const_1 ]])
point = TT(_sage_const_1 , edges = [], C0 = [[_sage_const_0 ]], C1 = [], C2 = [])
point2 = TT(_sage_const_1 , edges = [], C0 = [], C1 = [[_sage_const_0 ]], C2 = [])
positives = [edge_12 - _sage_const_1 /_sage_const_2 *edge_01, point - _sage_const_1 /_sage_const_3 , point2 - _sage_const_2 /_sage_const_3 , pairs_12 - _sage_const_2 /_sage_const_9 ]

# Missing edges (correct?)
M = _sage_const_1  + TT(_sage_const_2 , edges=[], C0=[], C1=[[_sage_const_0 ]], C2=[[_sage_const_1 ]]) - _sage_const_1 

# Bad edges (correct?)
B = _sage_const_1 
B += TT(_sage_const_2 , edges=[[_sage_const_0 , _sage_const_1 ]], C0=[[_sage_const_0 ]], C1=[[_sage_const_1 ]], C2=[])
B += TT(_sage_const_2 , edges=[[_sage_const_0 , _sage_const_1 ]], C0=[], C1=[[_sage_const_0 ], [_sage_const_1 ]], C2=[])
B -= _sage_const_1 

# print(M + B)

# Optimize (correct?)
# cons = TT.blowup_construction(target_size = 5, pattern_size = 3, symmetric=False, edges = [[1, 2]], C0 = [[0]], C1 = [[1]], C2 = [[2]])
x = TT.optimize(B - M, _sage_const_5 , maximize=True, positives = positives)
print(x)

