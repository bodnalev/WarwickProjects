

# This file was *autogenerated* from the file no_k4m.sage
from sage.all_cmdline import *   # import sage library

_sage_const_4 = Integer(4); _sage_const_0 = Integer(0); _sage_const_1 = Integer(1); _sage_const_2 = Integer(2); _sage_const_3 = Integer(3); _sage_const_5 = Integer(5); _sage_const_6 = Integer(6); _sage_const_7 = Integer(7); _sage_const_35 = Integer(35); _sage_const_15 = Integer(15); _sage_const_9 = Integer(9)
from sage.algebras.flag_algebras import *

# This is some hack to create the theory for 3-graphs without C5- and K4-
# up to size 7. It is easier to make them as extensions of 6 sized structures
# so this code does that.

def check_containment(smalls, larges):
    """
    Helper function to check is any of the smalls appears in each of the larges.

    INPUT:
    smalls - list of flags, must be from a theory with edges relation
    larges - list of flags, also must be from a theory with edges relation

    OUTPUT:
    list of booleans, i-th element represents if i-th large flag is free from all smalls
    """
    sis = [IncidenceStructure(ss.size(), ss.blocks()['edges']) for ss in smalls]
    lis = [IncidenceStructure(ss.size(), ss.blocks()['edges']) for ss in larges]
    res = []
    for ll in lis:
        good = True
        for ss in sis:
            for _ in ll.isomorphic_substructures_iterator(ss):
                good = False
                break
            if not good:
                break
        res.append(good)
    return res

# Reset three graphs, so nothing is excluded
TG = ThreeGraphTheory
# k4 and k4m (the two induced structures with size 4 excluded)
k4 = TG(_sage_const_4 , edges=[[_sage_const_0 , _sage_const_1 , _sage_const_2 ], [_sage_const_0 , _sage_const_1 , _sage_const_3 ], [_sage_const_0 , _sage_const_2 , _sage_const_3 ], [_sage_const_1 , _sage_const_2 , _sage_const_3 ]])
k4m = TG(_sage_const_4 , edges=[[_sage_const_0 , _sage_const_1 , _sage_const_2 ], [_sage_const_0 , _sage_const_1 , _sage_const_3 ], [_sage_const_0 , _sage_const_2 , _sage_const_3 ]])
excls = [k4,k4m]
TG.exclude(excls)

# check the list of flags with size 5 and 6
fl5 = TG.generate_flags(_sage_const_5 )
fl6 = TG.generate_flags(_sage_const_6 )

# quick 3-graph identifier code. This will be the identifier for
# the theory of C5- free 3-graphs (any identifier working for 3-graphs can work here)
def _identify_hypergraph(n, ftype_points, edges):
    g = Graph([list(range(n+len(edges))), [(i+n,x) for i,b in enumerate(edges) for x in b]], 
              format='vertices_and_edges')
    ftype_union = [jj for ff in ftype_points for jj in ff]
    partt = list(ftype_points) +             [[ii for ii in range(n) if ii not in ftype_union]] +             [list(range(n,n+len(edges)))]
    blocks = tuple(g.canonical_label(partition=partt).edges(labels=None, sort=True))
    return (n, tuple([len(xx) for xx in ftype_points]), blocks)

# generator code. It should really just return TG, but for size 7 that takes too long
# so this hack just returns TG for size up to 6, and for 7 it generates all flags
# with this extension technique
def _gen(n):
    if n<=_sage_const_4 :
        for xx in TG.generate_flags(n):
            yield xx.blocks()
    elif n==_sage_const_5 :
        for xx in fl5:
            yield xx.blocks()
    elif n==_sage_const_6 :
        for xx in fl6:
            yield xx.blocks()
    elif n==_sage_const_7 :
        import itertools
        from tqdm import tqdm
        fl7_m = [[] for ii in range(_sage_const_35 +_sage_const_1 )]
        subs = list(itertools.combinations(range(_sage_const_6 ), int(_sage_const_2 )))
        for xx in tqdm(fl6):
            xb = xx.blocks()['edges']
            for ii in range(_sage_const_15 +_sage_const_1 ):
                for pps in itertools.combinations(subs, int(ii)):
                    xbp = [[pp[_sage_const_0 ], pp[_sage_const_1 ], _sage_const_6 ] for pp in pps] + xb
                    flxp = TG(_sage_const_7 , edges=xbp)
                    en = len(xbp)
                    if flxp not in fl7_m[en]:
                        if check_containment(excls, [flxp])[_sage_const_0 ]:
                            fl7_m[en].append(flxp)
        fl7 = [yy for xx in fl7_m for yy in xx]
        for xx in fl7:
            yield xx.blocks()
    else:
        #for n>=8 just return an empty list, this will not be called so doesn't 
        #really matter
        return []

# Create the theory based on this generator and identifier
TGp = CombinatorialTheory("NoK4m", _gen, _identify_hypergraph, edges=_sage_const_3 )

# for sanity check, print the number of structures with size 5, 6, 7
# should be 11 106 8157
# print(len(TGp.generate_flags(5)), len(TGp.generate_flags(6)), len(TGp.generate_flags(7)))


#############################################################################################

tp = TGp(_sage_const_3 , ftype=[_sage_const_0 , _sage_const_1 , _sage_const_2 ], edges=[[_sage_const_0 , _sage_const_1 , _sage_const_2 ]])
all_6 = TGp.generate_flags(_sage_const_6 , tp)
all_6_flags = []

for f in all_6:
    # Re-label vertices to match type [0, 1, 2]
    roots = f.ftype_points()
    edges = f.blocks()['edges'].copy()
    isom = [-_sage_const_1  for i in range(_sage_const_6 )]
    for i in range(_sage_const_3 ):
        isom[ roots[i] ] = i
    idx = _sage_const_3 
    for i in range(_sage_const_6 ):
        if isom[i] == -_sage_const_1 :
            isom[i] = idx
            idx += _sage_const_1 
    for i in range(len(edges)):
        for j in range(len(edges[i])):
            edges[i][j] = isom[ edges[i][j] ]
        edges[i] = sorted(edges[i])
        
    # Re-labeled flag
    flag = TGp(_sage_const_6 , ftype=[_sage_const_0 , _sage_const_1 , _sage_const_2 ], edges=edges)
    
    # Only preserve flags that contain edge [3, 4, 5]
    if [_sage_const_3 , _sage_const_4 , _sage_const_5 ] not in flag.blocks()['edges']:
        continue

    # Get pattern of the top vertices
    states = [[], [], []]
    for v in [_sage_const_3 , _sage_const_4 , _sage_const_5 ]:
        for e in edges:
            if v in e:
                t = [x for x in e if x <= _sage_const_2 ]
                if len(t) > _sage_const_1 :
                    states[v - _sage_const_3 ] += t
    for i in range(_sage_const_3 ):
        states[i] = list({_sage_const_0 , _sage_const_1 , _sage_const_2 }.difference(set(states[i])))
        if len(states[i]) == _sage_const_1 :
            states[i] = states[i][_sage_const_0 ]
        elif len(states[i]) == _sage_const_2 :
            print("FATAL ERROR")
        else:
            states[i] = -_sage_const_1 

    all_6_flags.append([flag, states])

T_3 = _sage_const_1 
for flag, states in all_6_flags:
    # Add flags with coefficients
    if (len(set(states)) == _sage_const_2  and -_sage_const_1  not in states) or len(set(states)) == _sage_const_3 :
        continue
    if states.count(-_sage_const_1 ) in [_sage_const_3 , _sage_const_2 ]:
        T_3 += flag / _sage_const_9 
    elif states.count(-_sage_const_1 ) == _sage_const_1 :
        T_3 += flag / _sage_const_3 
    else:
        T_3 += flag
    # print(flag)
    # print(states)
T_3 -= _sage_const_1 

T_111 = _sage_const_1 
for flag, states in all_6_flags:
    if -_sage_const_1  not in states and len(set(states)) == _sage_const_1 :
        continue
    if states.count(-_sage_const_1 ) == _sage_const_1  and len(set(states)) == _sage_const_2 :
        continue
    # Add flags with coefficients
    if states.count(-_sage_const_1 ) == _sage_const_2  and len(set(states)) == _sage_const_2 :
        T_111 += flag * _sage_const_2  / _sage_const_9 
    elif states.count(-_sage_const_1 ) == _sage_const_3 :
        T_111 += flag * _sage_const_2  / _sage_const_9 
    elif states.count(-_sage_const_1 ) == _sage_const_1  and len(set(states)) == _sage_const_3 :
        T_111 += flag / _sage_const_3 
    else:
        T_111 += flag
    # print(flag)
    # print(states)
T_111 -= _sage_const_1 

T_21 = _sage_const_1 
for flag, states in all_6_flags:
    if -_sage_const_1  not in states and len(set(states)) == _sage_const_1 :
        continue
    if -_sage_const_1  not in states and len(set(states)) == _sage_const_3 :
        continue
    # Add flags with coefficients
    if -_sage_const_1  not in states and len(set(states)) == _sage_const_2 :
        T_21 += flag
    else:
        T_21 += flag * _sage_const_2  / _sage_const_3 
    # print(flag)
    # print(states)
T_21 -= _sage_const_1 

# Optimise
degree = TGp(_sage_const_3 , edges=[[_sage_const_0 ,_sage_const_1 ,_sage_const_2 ]], ftype=[_sage_const_0 ])
p2f4 = TGp.generate_flags(_sage_const_4 , TGp(_sage_const_2 , ftype=[_sage_const_0 , _sage_const_1 ]))
degree_difference = p2f4[_sage_const_2 ]-p2f4[_sage_const_3 ]+p2f4[_sage_const_5 ]-p2f4[_sage_const_6 ]
positives = [degree-_sage_const_2 /_sage_const_7 , degree_difference, -degree_difference]

# a_3 <= 0.02148518586113618
# [T_3 - 0.0214]
# ans = TGp.optimize_problem(T_3, 6, maximize=True, positives=positives)
# print(ans)

# a_111 >= 0.20655245288809151
# ans = TGp.optimize_problem(T_111, 6, maximize=False, positives=positives)
# print(ans)

# a_21 >= 0.15849272791779434
# ans = TGp.optimize_problem(T_21, 6, maximize=False, positives=positives)
# print(ans)

# (a_111 + a_21) / 2 >= 0.1995627514370104
ans = TGp.optimize_problem((T_111 + T_21) / _sage_const_2 , _sage_const_6 , maximize=False, positives=positives)
print(ans)

