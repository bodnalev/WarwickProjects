

# This file was *autogenerated* from the file script-stability_C5-_ordered.sage
from sage.all_cmdline import *   # import sage library

_sage_const_2 = Integer(2); _sage_const_0 = Integer(0); _sage_const_1 = Integer(1); _sage_const_4 = Integer(4); _sage_const_3 = Integer(3); _sage_const_36 = Integer(36); _sage_const_100 = Integer(100); _sage_const_5 = Integer(5)
from sage.algebras.flag_algebras import *
import itertools

# Create the theory
def test_identify(n, ftype_points, edges, C0, C1, C2):
    return colored_identify(_sage_const_2 , [[_sage_const_0 ], [_sage_const_1 ], [_sage_const_2 ]], n, ftype_points, edges=edges, C0=C0, C1=C1, C2=C2)

def test_generate(n):
    return colored_generate(_sage_const_2 , [[_sage_const_0 ], [_sage_const_1 ], [_sage_const_2 ]], n)

TT = CombinatorialTheory("123graphs", test_generate, test_identify, edges=_sage_const_2 , C0=_sage_const_1 , C1=_sage_const_1 , C2=_sage_const_1 )

feasibles = []
for flag in TT.generate_flags(_sage_const_4 ):
    # Real edges
    edge_list = [sorted(x + [_sage_const_4 ]) for x in flag.blocks()['edges']]
    # Add rainbow edges
    for v1 in flag.blocks()['C0']:
        for v2 in flag.blocks()['C1']:
            for v3 in flag.blocks()['C2']:
                l = sorted([v1[_sage_const_0 ], v2[_sage_const_0 ], v3[_sage_const_0 ]])
                if l not in edge_list:
                    edge_list.append(l)
    # Look for C5-
    feasible = True
    for p in list(itertools.permutations([_sage_const_0 , _sage_const_1 , _sage_const_2 , _sage_const_3 , _sage_const_4 ])):
        if sorted([p[_sage_const_0 ], p[_sage_const_1 ], p[_sage_const_2 ]]) in edge_list and sorted([p[_sage_const_1 ], p[_sage_const_2 ], p[_sage_const_3 ]]) in edge_list and sorted([p[_sage_const_2 ], p[_sage_const_3 ], p[_sage_const_4 ]]) in edge_list and sorted([p[_sage_const_3 ], p[_sage_const_4 ], p[_sage_const_0 ]]) in edge_list:
            feasible = False
            break
    # Account for this flag
    if feasible:
        feasibles.append(flag)

print(len(feasibles))

exclude = [flag for flag in TT.generate_flags(_sage_const_4 ) if flag not in feasibles]

TT.exclude(exclude)

# Assumptions
edge_00 = TT(_sage_const_2 , edges=[[_sage_const_0 , _sage_const_1 ]], C0=[[_sage_const_0 ], [_sage_const_1 ]], C1=[], C2=[])
edge_11 = TT(_sage_const_2 , edges=[[_sage_const_0 , _sage_const_1 ]], C0=[], C1=[[_sage_const_0 ], [_sage_const_1 ]], C2=[])
edge_22 = TT(_sage_const_2 , edges=[[_sage_const_0 , _sage_const_1 ]], C0=[], C1=[], C2=[[_sage_const_0 ], [_sage_const_1 ]])
edge_01 = TT(_sage_const_2 , edges=[[_sage_const_0 , _sage_const_1 ]], C0=[[_sage_const_0 ]], C1=[[_sage_const_1 ]], C2=[])
edge_12 = TT(_sage_const_2 , edges=[[_sage_const_0 , _sage_const_1 ]], C0=[], C1=[[_sage_const_0 ]], C2=[[_sage_const_1 ]])
edge_02 = TT(_sage_const_2 , edges=[[_sage_const_0 , _sage_const_1 ]], C0=[[_sage_const_0 ]], C1=[], C2=[[_sage_const_1 ]])
point0 = TT(_sage_const_1 , edges = [], C0 = [[_sage_const_0 ]], C1 = [], C2 = [])
point1 = TT(_sage_const_1 , edges = [], C0 = [], C1 = [[_sage_const_0 ]], C2 = [])
point2 = TT(_sage_const_1 , edges = [], C0 = [], C1 = [], C2 = [[_sage_const_0 ]])
positives = [edge_12 - edge_01, edge_12 - edge_02, point0 - _sage_const_1 /_sage_const_3 , point1 - _sage_const_1 /_sage_const_3 , point2 - _sage_const_1 /_sage_const_3 ]

# # forall i, d(v_i) <= 1/4
positives += [_sage_const_1 /_sage_const_36  - edge_00, _sage_const_1 /_sage_const_36  - edge_11, _sage_const_1 /_sage_const_36  -  edge_22]

# # d(v) >= 1 / 4
positives += [edge_00 + edge_11 + edge_22 + edge_01 + edge_12 + edge_02 - _sage_const_1 /_sage_const_4 ]

# Third
positives += [edge_12 - _sage_const_1 /_sage_const_100 ]

# Missing edges
M = _sage_const_1  + TT(_sage_const_2 , edges=[], C0=[], C1=[[_sage_const_0 ]], C2=[[_sage_const_1 ]]) - _sage_const_1 

# Bad edges
B = _sage_const_1 
B += TT(_sage_const_2 , edges=[[_sage_const_0 , _sage_const_1 ]], C0=[[_sage_const_0 ]], C1=[[_sage_const_1 ]], C2=[])
B += TT(_sage_const_2 , edges=[[_sage_const_0 , _sage_const_1 ]], C0=[[_sage_const_0 ]], C1=[], C2=[[_sage_const_1 ]])
B += TT(_sage_const_2 , edges=[[_sage_const_0 , _sage_const_1 ]], C0=[], C1=[[_sage_const_0 ], [_sage_const_1 ]], C2=[])
B += TT(_sage_const_2 , edges=[[_sage_const_0 , _sage_const_1 ]], C0=[], C1=[], C2=[[_sage_const_0 ], [_sage_const_1 ]])
B -= _sage_const_1 

# Optimize
# const = TT.blowup_construction(5, 3, edges=[[1, 2]], C0=[[0]], C1=[[1]], C2=[[2]])
# x = TT.optimize(B - M, 5, maximize=True, positives = positives, exact=True, construction=const)
# print(x)

x = TT.optimize(B - M, _sage_const_5 , maximize=True, positives = positives)
print(x)

