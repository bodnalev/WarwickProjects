

# This file was *autogenerated* from the file script-stability_C5-_ordered.sage
from sage.all_cmdline import *   # import sage library

_sage_const_5 = Integer(5); _sage_const_0 = Integer(0); _sage_const_1 = Integer(1); _sage_const_2 = Integer(2); _sage_const_3 = Integer(3); _sage_const_4 = Integer(4); _sage_const_0p99 = RealNumber('0.99')
from sage.algebras.flag_algebras import *

def check_containment(smalls, larges):
    sis = [IncidenceStructure(ss.size(), ss.blocks()['edges']) for ss in smalls]
    lis = [IncidenceStructure(ss.size(), ss.blocks()['edges']) for ss in larges]
    res = []
    for ll in lis:
        good = True
        for ss in sis:
            for _ in ll.isomorphic_substructures_iterator(ss):
                good = False
                break
            if not good:
                break
        res.append(good)
    return res

TG = ThreeGraphTheory
TG.exclude()
C5m = TG(_sage_const_5 , edges=[[_sage_const_0 , _sage_const_1 , _sage_const_2 ], [_sage_const_1 , _sage_const_2 , _sage_const_3 ], [_sage_const_2 , _sage_const_3 , _sage_const_4 ], [_sage_const_3 , _sage_const_4 , _sage_const_0 ]])
fl5 = TG.generate_flags(_sage_const_5 )

gs = check_containment([C5m], fl5)
exls = [xx for ii, xx in enumerate(fl5) if not gs[ii]]
TG.exclude(exls)
#update graphs with size 5
fl5 = TG.generate_flags(_sage_const_5 )

def _identifyCT(k, order_partition, n, ftype_points, **kwargs):
    is_graph = (k==_sage_const_2 )
    color_number = sum(len(xx) for xx in order_partition)
    edges = kwargs["edges"]
    ftype_union = [jj for ff in ftype_points for jj in ff]
    Cs = [[cx[_sage_const_0 ] for cx in kwargs["C{}".format(ii)]] for ii in range(color_number)]
    g_parts = list(ftype_points) +               [[ii for ii in range(n) if ii not in ftype_union]]
    ppadd = _sage_const_0  if is_graph else len(edges)
    g_verts = list(range(n+ppadd+color_number))
    g_parts.append(list(range(n, n+ppadd)))
    g_parts += [[n+ppadd+ii for ii in partition_j] for partition_j in order_partition]
    if is_graph:
        g_edges = list(edges)
        for ii in range(color_number):
            g_edges += [(xx, n+ii) for xx in Cs[ii]]
    else:
        g_edges = [(i+n,x) for i,b in enumerate(edges) for x in b]
        for ii in range(color_number):
            g_edges += [(xx, n+len(edges)+ii) for xx in Cs[ii]]
    g = Graph([g_verts, g_edges], format='vertices_and_edges')
    blocks = tuple(g.canonical_label(partition=g_parts).edges(labels=None, sort=True))
    return (n, tuple([len(xx) for xx in ftype_points]), blocks)

def _generateCT(base_theory, k, order_partition, n):
    color_number = sum(len(xx) for xx in order_partition)
    BT = base_theory
    for xx in BT.generate_flags(n):
        unique = []
        edges = xx.blocks()['edges']

        for yy in itertools.product(range(color_number), repeat=int(n)):
            yy = list(yy)
            Cs = {"C{}".format(cc):[[ii] for ii, oo in enumerate(yy) if oo==cc] for cc in range(color_number)}
            iden = _identifyCT(k==_sage_const_2 , order_partition, n, [], edges=edges, **Cs)
            if iden not in unique:
                unique.append(iden)
                Cs["edges"] = edges
                yield Cs

# To make the default codes work for this specific case:
# The generator:
# Colors the elements of TGp (3-graphs without C5- and K4-), works on 3-uniform structures
# and the colors 0, 1, 2 are interchangeable (otherwise it would say [[0], [1], [2]]
GraphTheory.exclude()
def generate_colored(n):
    return _generateCT(TG, _sage_const_3 , [[_sage_const_0 ], [_sage_const_1 ], [_sage_const_2 ]], n)

# Same for the identifier. Colors are interchangeable.
def identify_colored(n, ftype_points, edges, C0, C1, C2):
    return _identifyCT(_sage_const_3 , [[_sage_const_0 ], [_sage_const_1 ], [_sage_const_2 ]], n, ftype_points, edges=edges, C0=C0, C1=C1, C2=C2)

CTGp = CombinatorialTheory("ColoredNoC5mYesK4m", generate_colored, identify_colored, edges=_sage_const_3 , C0=_sage_const_1 , C1=_sage_const_1 , C2=_sage_const_1 )

CTGp.exclude(CTGp(_sage_const_3 , edges=[], C0=[[_sage_const_0 ]], C1=[[_sage_const_1 ]], C2=[[_sage_const_2 ]]))

# Create the theory
def test_identify(n, ftype_points, edges, C0, C1, C2):
    return colored_identify(_sage_const_2 , [[_sage_const_0 ], [_sage_const_1 ], [_sage_const_2 ]], n, ftype_points, edges=edges, C0=C0, C1=C1, C2=C2)

def test_generate(n):
    return colored_generate(_sage_const_2 , [[_sage_const_0 ], [_sage_const_1 ], [_sage_const_2 ]], n)

TT = CombinatorialTheory("123ColLinkNoC5", test_generate, test_identify, edges=_sage_const_2 , C0=_sage_const_1 , C1=_sage_const_1 , C2=_sage_const_1 )
# TT.clear()
TT.exclude()

print(len(TT.generate_flags(_sage_const_4 )))

# Generate all feasible graphs on 4 vertices
all_flags = CTGp.generate_flags(_sage_const_5 )
feasible = []
for flag in all_flags:
    edges = flag.blocks()['edges']
    C0, C1, C2 = flag.blocks()['C0'], flag.blocks()['C1'], flag.blocks()['C2']
    for v in range(_sage_const_5 ):
        if [v] not in C0:
            continue
        # Find the link graph of v
        link_edges = []
        for e in edges:
            if v in e:
                link_edges.append([v if x == _sage_const_4  else x for x in e if x != v])
        g = TT(_sage_const_4 ,
                 edges=link_edges,
                 C0=[[v] if x == [_sage_const_4 ] else x for x in C0 if x != [v]],
                 C1=[[v] if x == [_sage_const_4 ] else x for x in C1 if x != [v]],
                 C2=[[v] if x == [_sage_const_4 ] else x for x in C2 if x != [v]])
        if g not in feasible:
            feasible.append(g)

print(len(feasible))

# l = []
# for flag in feasible:
#     if len(flag.blocks()['C0']) == 4 or len(flag.blocks()['C1']) == 4 or len(flag.blocks()['C2']) == 4:
#         l.append(flag)
#         print(flag)
#         # print(flag)
#     # if len(flag.blocks()['edges']) == 6:
#     #     print(flag)
# print(len(l))
# exit(1)

exclude = [flag for flag in TT.generate_flags(_sage_const_4 ) if flag not in feasible]

print(len(exclude))
TT.exclude(exclude)

# Assumptions
edge_01 = TT(_sage_const_2 , edges=[[_sage_const_0 , _sage_const_1 ]], C0=[[_sage_const_0 ]], C1=[[_sage_const_1 ]], C2=[])
edge_12 = TT(_sage_const_2 , edges=[[_sage_const_0 , _sage_const_1 ]], C0=[], C1=[[_sage_const_0 ]], C2=[[_sage_const_1 ]])
edge_02 = TT(_sage_const_2 , edges=[[_sage_const_0 , _sage_const_1 ]], C0=[[_sage_const_0 ]], C1=[], C2=[[_sage_const_1 ]])
point0 = TT(_sage_const_1 , edges = [], C0 = [[_sage_const_0 ]], C1 = [], C2 = [])
point1 = TT(_sage_const_1 , edges = [], C0 = [], C1 = [[_sage_const_0 ]], C2 = [])
point2 = TT(_sage_const_1 , edges = [], C0 = [], C1 = [], C2 = [[_sage_const_0 ]])
positives = [edge_12 - edge_01, edge_12 - edge_02, point0 - _sage_const_1 /_sage_const_3 , point1 - _sage_const_1 /_sage_const_3 , point2 - _sage_const_1 /_sage_const_3 ]

# Missing edges
M = _sage_const_1  + TT(_sage_const_2 , edges=[], C0=[], C1=[[_sage_const_0 ]], C2=[[_sage_const_1 ]]) - _sage_const_1 

# Bad edges
B = _sage_const_1 
B += TT(_sage_const_2 , edges=[[_sage_const_0 , _sage_const_1 ]], C0=[[_sage_const_0 ]], C1=[[_sage_const_1 ]], C2=[])
B += TT(_sage_const_2 , edges=[[_sage_const_0 , _sage_const_1 ]], C0=[[_sage_const_0 ]], C1=[], C2=[[_sage_const_1 ]])
B += TT(_sage_const_2 , edges=[[_sage_const_0 , _sage_const_1 ]], C0=[], C1=[[_sage_const_0 ], [_sage_const_1 ]], C2=[])
B += TT(_sage_const_2 , edges=[[_sage_const_0 , _sage_const_1 ]], C0=[], C1=[], C2=[[_sage_const_0 ], [_sage_const_1 ]])
B -= _sage_const_1 

# # Optimize
# const = TT.blowup_construction(5, 3, edges=[[1, 2]], C0=[[0]], C1=[[1]], C2=[[2]])
# x = TT.optimize(B - M, 5, maximize=True, positives = positives, exact=True, construction=const)
# print(x)

x = TT.optimize(B - _sage_const_0p99 *M, _sage_const_5 , maximize=True, positives = positives)
print(x)


# # from sage.algebras.flag_algebras import *

# # # These are helper functions, to deal with classical exclusion (not just induced)
# # def check_containment(smalls, larges):
# #     sis = [IncidenceStructure(ss.size(), ss.blocks()['edges']) for ss in smalls]
# #     lis = [IncidenceStructure(ss.size(), ss.blocks()['edges']) for ss in larges]
# #     res = []
# #     for ll in lis:
# #         good = True
# #         for ss in sis:
# #             for _ in ll.isomorphic_substructures_iterator(ss):
# #                 good = False
# #                 break
# #             if not good:
# #                 break
# #         res.append(good)
# #     return res

# # # This is some hack to create the theory for 3-graphs without C5- and K4-
# # # up to size 7. It is easier to make them as extensions of 6 sized structures
# # # so this code does that.

# # # Reset three graphs, so nothing is excluded
# # TG = ThreeGraphTheory
# # TG.exclude()

# # # C5 minus
# # C5m = TG(5, edges=[[0, 1, 2], [1, 2, 3], [2, 3, 4], [3, 4, 0]])

# # # flags of size 5
# # fl5 = TG.generate_flags(5)

# # # boolean vector indicating each element in fl5 if it has C5m
# # gs = check_containment([C5m], fl5)

# # # set the excluded structures. k4, k4m and all in fl5 containing C5m
# # exls = [xx for ii, xx in enumerate(fl5) if not gs[ii]]
# # TG.exclude(exls)

# # # check the list of flags with size 5 and 6
# # fl5 = TG.generate_flags(5)

# # # This is code to create colored theories
# # # This is a default code for all color partition
# # def _identifyCT(k, order_partition, n, ftype_points, **kwargs):
# #     is_graph = (k==2)
# #     color_number = sum(len(xx) for xx in order_partition)
# #     edges = kwargs["edges"]
# #     ftype_union = [jj for ff in ftype_points for jj in ff]
# #     Cs = [[cx[0] for cx in kwargs["C{}".format(ii)]] for ii in range(color_number)]
# #     g_parts = list(ftype_points) + \
# #               [[ii for ii in range(n) if ii not in ftype_union]]
# #     ppadd = 0 if is_graph else len(edges)
# #     g_verts = list(range(n+ppadd+color_number))
# #     g_parts.append(list(range(n, n+ppadd)))
   
# #     g_parts += [[n+ppadd+ii for ii in partition_j] for partition_j in order_partition]
   
# #     if is_graph:
# #         g_edges = list(edges)
# #         for ii in range(color_number):
# #             g_edges += [(xx, n+ii) for xx in Cs[ii]]
# #     else:
# #         g_edges = [(i+n,x) for i,b in enumerate(edges) for x in b]
# #         for ii in range(color_number):
# #             g_edges += [(xx, n+len(edges)+ii) for xx in Cs[ii]]
# #     g = Graph([g_verts, g_edges], format='vertices_and_edges')
# #     blocks = tuple(g.canonical_label(partition=g_parts).edges(labels=None, sort=True))
# #     return (n, tuple([len(xx) for xx in ftype_points]), blocks)

# # # This is also a default code for all color partition
# # def _generateCT(base_theory, k, order_partition, n):
# #     color_number = sum(len(xx) for xx in order_partition)
# #     BT = base_theory
# #     for xx in BT.generate_flags(n):
# #         unique = []
# #         edges = xx.blocks()['edges']
       
# #         for yy in itertools.product(range(color_number), repeat=int(n)):
# #             yy = list(yy)
# #             Cs = {"C{}".format(cc):[[ii] for ii, oo in enumerate(yy) if oo==cc] for cc in range(color_number)}
# #             iden = _identifyCT(k==2, order_partition, n, [], edges=edges, **Cs)
# #             if iden not in unique:
# #                 unique.append(iden)
# #                 Cs["edges"] = edges
# #                 yield Cs

# # # To make the default codes work for this specific case:
# # # The generator:
# # # Colors the elements of TGp (3-graphs without C5- and K4-), works on 3-uniform structures
# # # and the colors 0, 1, 2 are interchangeable (otherwise it would say [[0], [1], [2]]
# # def generate_colored(n):
# #     return _generateCT(TG, 3, [[0], [1], [2]], n)

# # # Same for the identifier. Colors are interchangeable.
# # def identify_colored(n, ftype_points, edges, C0, C1, C2):
# #     return _identifyCT(3, [[0], [1], [2]], n, ftype_points, edges=edges, C0=C0, C1=C1, C2=C2)

# # # CTGp is the colored variant of TGp (NoC5m)
# # CTGp = CombinatorialTheory("ColoredNoC5mYesK4m", generate_colored, identify_colored, edges=3, C0=1, C1=1, C2=1)

# # # sanity check, the number of flags with size 4, 5, 6
# # # should be 18 132 2840
# # # print(len(CTGp.generate_flags(4)), len(CTGp.generate_flags(5)))

# ###
# ### This cell is just to set up the theory.
# ### In practice it is not needed, as the calculations (multiplication table and generated structures)
# ### are already done and saved. But it is here for completeness (and for re-runs from scratch)
# ###

# from sage.algebras.flag_algebras import *

# def check_containment(smalls, larges):
#     sis = [IncidenceStructure(ss.size(), ss.blocks()['edges']) for ss in smalls]
#     lis = [IncidenceStructure(ss.size(), ss.blocks()['edges']) for ss in larges]
#     res = []
#     for ll in lis:
#         good = True
#         for ss in sis:
#             for _ in ll.isomorphic_substructures_iterator(ss):
#                 good = False
#                 break
#             if not good:
#                 break
#         res.append(good)
#     return res

# TG = ThreeGraphTheory
# TG.exclude()
# C5m = TG(5, edges=[[0, 1, 2], [1, 2, 3], [2, 3, 4], [3, 4, 0]])
# fl5 = TG.generate_flags(5)
# gs = check_containment([C5m], fl5)
# exls = [xx for ii, xx in enumerate(fl5) if not gs[ii]]
# TG.exclude(exls)
# #update graphs with size 5
# fl5 = TG.generate_flags(5)

# def _identifyCT(k, order_partition, n, ftype_points, **kwargs):
#     is_graph = (k==2)
#     color_number = sum(len(xx) for xx in order_partition)
#     edges = kwargs["edges"]
#     ftype_union = [jj for ff in ftype_points for jj in ff]
#     Cs = [[cx[0] for cx in kwargs["C{}".format(ii)]] for ii in range(color_number)]
#     g_parts = list(ftype_points) + \
#               [[ii for ii in range(n) if ii not in ftype_union]]
#     ppadd = 0 if is_graph else len(edges)
#     g_verts = list(range(n+ppadd+color_number))
#     g_parts.append(list(range(n, n+ppadd)))
#     g_parts += [[n+ppadd+ii for ii in partition_j] for partition_j in order_partition]
#     if is_graph:
#         g_edges = list(edges)
#         for ii in range(color_number):
#             g_edges += [(xx, n+ii) for xx in Cs[ii]]
#     else:
#         g_edges = [(i+n,x) for i,b in enumerate(edges) for x in b]
#         for ii in range(color_number):
#             g_edges += [(xx, n+len(edges)+ii) for xx in Cs[ii]]
#     g = Graph([g_verts, g_edges], format='vertices_and_edges')
#     blocks = tuple(g.canonical_label(partition=g_parts).edges(labels=None, sort=True))
#     return (n, tuple([len(xx) for xx in ftype_points]), blocks)

# def _generateCT(base_theory, k, order_partition, n):
#     color_number = sum(len(xx) for xx in order_partition)
#     BT = base_theory
#     for xx in BT.generate_flags(n):
#         unique = []
#         edges = xx.blocks()['edges']
       
#         for yy in itertools.product(range(color_number), repeat=int(n)):
#             yy = list(yy)
#             Cs = {"C{}".format(cc):[[ii] for ii, oo in enumerate(yy) if oo==cc] for cc in range(color_number)}
#             iden = _identifyCT(k==2, order_partition, n, [], edges=edges, **Cs)
#             if iden not in unique:
#                 unique.append(iden)
#                 Cs["edges"] = edges
#                 yield Cs

# # To make the default codes work for this specific case:
# # The generator:
# # Colors the elements of TGp (3-graphs without C5- and K4-), works on 3-uniform structures
# # and the colors 0, 1, 2 are interchangeable (otherwise it would say [[0], [1], [2]]
# def generate_colored(n):
#     return _generateCT(TG, 3, [[0], [1], [2]], n)

# # Same for the identifier. Colors are interchangeable.
# def identify_colored(n, ftype_points, edges, C0, C1, C2):
#     return _identifyCT(3, [[0], [1], [2]], n, ftype_points, edges=edges, C0=C0, C1=C1, C2=C2)
                
# CTGp = CombinatorialTheory("ColoredNoC5mYesK4m", generate_colored, identify_colored, edges=3, C0=1, C1=1, C2=1)
# #Then you can also force that all the edges containing all three colors are present by excluding the rainbow non-edge
# CTGp.exclude(CTGp(3, edges=[], C0=[[0]], C1=[[1]], C2=[[2]]))

# # Generate all feasible graphs on 4 vertices
# all_flags = CTGp.generate_flags(5)
# feasible = []
# for flag in all_flags:
#     edges = flag.blocks()['edges']
#     C0, C1, C2 = flag.blocks()['C0'], flag.blocks()['C1'], flag.blocks()['C2']
#     for v in range(5):
#         # Find the link graph of v
#         link_edges = []
#         for e in edges:
#             if v in e:
#                 link_edges.append([v if x == 4 else x for x in e if x != v])
#         g = CTGp(4,
#                  edges=link_edges,
#                  C0=[[v] if x == [4] else x for x in C0 if x != [v]],
#                  C1=[[v] if x == [4] else x for x in C1 if x != [v]],
#                  C2=[[v] if x == [4] else x for x in C2 if x != [v]])
#         if g not in feasible:
#             feasible.append(g)


# # Create the theory
# def test_identify(n, ftype_points, edges, C0, C1, C2):
#     return colored_identify(3, [[0], [1], [2]], n, ftype_points, edges=edges, C0=C0, C1=C1, C2=C2)

# def test_generate(n):
#     return colored_generate(3, [[0], [1], [2]], n)

# TT = CombinatorialTheory("123ColLinkNoC5", test_generate, test_identify, edges=2, C0=1, C1=1, C2=1)
# exclude = [flag for flag in TT.generate_flags(4) if flag not in feasible]
# TT.exclude(exclude)

# # Assumptions
# edge_01 = TT(2, edges=[[0, 1]], C0=[[0]], C1=[[1]], C2=[[1]])
# edge_12 = TT(2, edges=[[0, 1]], C0=[], C1=[[0]], C2=[[1]])
# edge_02 = TT(2, edges=[[0, 1]], C0=[[0]], C1=[], C2=[[1]])
# point0 = TT(1, edges = [], C0 = [[0]], C1 = [], C2 = [])
# point1 = TT(1, edges = [], C0 = [], C1 = [[0]], C2 = [])
# point2 = TT(1, edges = [], C0 = [], C1 = [], C2 = [[0]])
# # pairs_12 = TT(2, edges=[[0, 1]], C0=[], C1=[[0]], C2=[[1]]) + TT(2, edges=[], C0=[], C1=[[0]], C2=[[1]])
# # point = TT(1, edges = [], C0 = [[0]], C1 = [], C2 = [])
# # point2 = TT(1, edges = [], C0 = [], C1 = [[0]], C2 = [])
# # positives = [point - 1/3, point2 - 2/3, pairs_12 - 2/9]
# positives = [edge_12 - edge_01, edge_12 - edge_02, point0 - 1/3, point1 - 1/3, point2 - 1/3]

# # Missing edges
# M = 1 + TT(2, edges=[], C0=[], C1=[[0]], C2=[[1]]) - 1

# # Bad edges
# B = 1
# B += TT(2, edges=[[0, 1]], C0=[[0]], C1=[[1]], C2=[])
# B += TT(2, edges=[[0, 1]], C0=[[0]], C1=[], C2=[[1]])
# B += TT(2, edges=[[0, 1]], C0=[], C1=[[0], [1]], C2=[])
# B += TT(2, edges=[[0, 1]], C0=[], C1=[], C2=[[0], [1]])
# B -= 1

# # # Optimize
# x = TT.optimize(B - M, 5, maximize=True, positives = positives)
# # print(x)



