

# This file was *autogenerated* from the file script-stability_C5-_graphs.sage
from sage.all_cmdline import *   # import sage library

_sage_const_2 = Integer(2); _sage_const_0 = Integer(0); _sage_const_1 = Integer(1); _sage_const_4 = Integer(4); _sage_const_3 = Integer(3); _sage_const_8 = Integer(8); _sage_const_5 = Integer(5); _sage_const_9 = Integer(9); _sage_const_10 = Integer(10)
from sage.algebras.flag_algebras import *
import itertools

# Create the theory
def test_identify(n, ftype_points, edges, C0, C1, C2):
    return colored_identify(_sage_const_2 , [[_sage_const_0 ], [_sage_const_1 ], [_sage_const_2 ]], n, ftype_points, edges=edges, C0=C0, C1=C1, C2=C2)

def test_generate(n):
    return colored_generate(_sage_const_2 , [[_sage_const_0 ], [_sage_const_1 ], [_sage_const_2 ]], n)

TT = CombinatorialTheory("test_theory", test_generate, test_identify, edges=_sage_const_2 , C0=_sage_const_1 , C1=_sage_const_1 , C2=_sage_const_1 )

def get_more_edges(n, edges):
    edge = edges.copy()
    for e in edge:
        e = sorted(e)
    gg = []
    for u, v in itertools.combinations([x for x in range(n)], _sage_const_2 ):
        if sorted([u, v]) not in edge:
            gg.append([u, v])
    return gg

exclude = []
# # Condition 1 (path)
# for flag in TT.generate_flags(4):
#     # Make sure it has 3 edges
#     if len(flag.blocks()['edges']) != 3:
#         continue
#     # Make sure it intersects all three parts
#     if flag.blocks()['C0'] == [] or flag.blocks()['C1'] == [] or flag.blocks()['C2'] == []:
#         continue
#     # Get the degree sequence and make sure it is 1, 1, 2, 2
#     seq = [0, 0, 0, 0]
#     for e in flag.blocks()['edges']:
#         seq[e[0]] += 1
#         seq[e[1]] += 1
#     if sorted(seq) != [1, 1, 2, 2]:
#         continue
#     # Check that the endpoints are in different parts
#     eq_ends = False
#     for i in range(4):
#         for j in range(i + 1, 4):
#             if seq[i] == seq[j] == 1 and (([i] in flag.blocks()['C0'] and [j] in flag.blocks()['C0']) or ([i] in flag.blocks()['C1'] and [j] in flag.blocks()['C1']) or ([i] in flag.blocks()['C2'] and [j] in flag.blocks()['C2'])):
#                 eq_ends = True
#     if eq_ends:
#         continue
#     # print(flag)
#     exclude.append(flag)
# print(len(exclude), "non-induced subgraphs to exclude")

# Condition 2.1 (two disjoint edges)
for flag in TT.generate_flags(_sage_const_4 ):
    # Make sure it has 2 edges
    if len(flag.blocks()['edges']) != _sage_const_2 :
        continue
    # Make sure it intersects all three parts
    if flag.blocks()['C0'] == [] or flag.blocks()['C1'] == [] or flag.blocks()['C2'] == []:
        continue
    # Get the degree sequence and make sure it is 1, 1, 1, 1
    seq = [_sage_const_0 , _sage_const_0 , _sage_const_0 , _sage_const_0 ]
    for e in flag.blocks()['edges']:
        seq[e[_sage_const_0 ]] += _sage_const_1 
        seq[e[_sage_const_1 ]] += _sage_const_1 
    if sorted(seq) != [_sage_const_1 , _sage_const_1 , _sage_const_1 , _sage_const_1 ]:
        continue
    # Make sure the edges go across parts
    across = True
    for e in flag.blocks()['edges']:
        i, j = e
        if [i] in flag.blocks()['C0'] and [j] in flag.blocks()['C0']:
            across = False
        if [i] in flag.blocks()['C1'] and [j] in flag.blocks()['C1']:
            across = False
        if [i] in flag.blocks()['C2'] and [j] in flag.blocks()['C2']:
            across = False
    if not across:
        continue
    # print(flag)
    exclude.append(flag)
print(len(exclude), "non-induced subgraphs to exclude")

# Condition 2.2 (two intersecting edges)
for flag in TT.generate_flags(_sage_const_3 ):
    # Make sure it has 2 edges
    if len(flag.blocks()['edges']) != _sage_const_2 :
        continue
    # Make sure it intersects all three parts
    if flag.blocks()['C0'] == [] or flag.blocks()['C1'] == [] or flag.blocks()['C2'] == []:
        continue
    # Get the degree sequence and make sure it is 1, 1, 2
    seq = [_sage_const_0 , _sage_const_0 , _sage_const_0 ]
    for e in flag.blocks()['edges']:
        seq[e[_sage_const_0 ]] += _sage_const_1 
        seq[e[_sage_const_1 ]] += _sage_const_1 
    if sorted(seq) != [_sage_const_1 , _sage_const_1 , _sage_const_2 ]:
        continue
    # Make sure the edges go across parts
    across = True
    for e in flag.blocks()['edges']:
        i, j = e
        if [i] in flag.blocks()['C0'] and [j] in flag.blocks()['C0']:
            across = False
        if [i] in flag.blocks()['C1'] and [j] in flag.blocks()['C1']:
            across = False
        if [i] in flag.blocks()['C2'] and [j] in flag.blocks()['C2']:
            across = False
    if not across:
        continue
    # print(flag)
    exclude.append(flag)
print(len(exclude), "non-induced subgraphs to exclude")

# Condition 3 (two edges)
for flag in TT.generate_flags(_sage_const_3 ):
    # Make sure it has 2 edges
    if len(flag.blocks()['edges']) != _sage_const_2 :
        continue
    # Make sure exactly one of the parts is empty
    if not (flag.blocks()['C0'] == [] or flag.blocks()['C1'] == [] or flag.blocks()['C2'] == []):
        continue
    two_empty = False
    for i in range(_sage_const_3 ):
        for j in range(i + _sage_const_1 , _sage_const_3 ):
            if flag.blocks()['C'+str(i)] == flag.blocks()['C'+str(j)] == []:
                two_empty = True
    if two_empty:
        continue
    # Get the degree sequence and make sure it is 1, 1, 2
    v = _sage_const_0 
    seq = [_sage_const_0 , _sage_const_0 , _sage_const_0 ]
    for e in flag.blocks()['edges']:
        seq[e[_sage_const_0 ]] += _sage_const_1 
        seq[e[_sage_const_1 ]] += _sage_const_1 
        if seq[e[_sage_const_0 ]] == _sage_const_2 :
            v = e[_sage_const_0 ]
        elif seq[e[_sage_const_1 ]] == _sage_const_2 :
            v = e[_sage_const_1 ]
    if sorted(seq) != [_sage_const_1 , _sage_const_1 , _sage_const_2 ]:
        continue
    # Make sure the degree 2 vertex is not the only in its part
    lonely = False
    for i in range(_sage_const_3 ):
        if flag.blocks()['C'+str(i)] == [[v]]:
            lonely = True
    if lonely:
        continue
    # print(flag)
    exclude.append(flag)
print(len(exclude), "non-induced subgraphs to exclude")

# # Condition 3 (two edges)
# for flag in TT.generate_flags(4):
#     # Make sure it has 2 edges
#     if len(flag.blocks()['edges']) != 2:
#         continue
#     # Make sure it intersects all three parts
#     if flag.blocks()['C0'] == [] or flag.blocks()['C1'] == [] or flag.blocks()['C2'] == []:
#         continue
#     # Get the degree sequence and make sure it is 0, 1, 1, 2
#     v = 0
#     u = 0
#     seq = [0, 0, 0, 0]
#     for e in flag.blocks()['edges']:
#         seq[e[0]] += 1
#         seq[e[1]] += 1
#         if seq[e[0]] == 2:
#             v = e[0]
#         elif seq[e[1]] == 2:
#             v = e[1]
#         if seq[e[0]] == 0:
#             u = e[0]
#         elif seq[e[1]] == 0:
#             u = e[1]
#     if sorted(seq) != [0, 1, 1, 2]:
#         continue
#     # Make sure the degree 0 vertex is the only in its part
#     lonely = False
#     for i in range(3):
#         if flag.blocks()['C'+str(i)] == [[u]]:
#             lonely = True
#     if not lonely:
#         continue
#     # Make sure the degree 2 vertex is not the only in its part
#     lonely = False
#     for i in range(3):
#         if flag.blocks()['C'+str(i)] == [[v]]:
#             lonely = True
#     if lonely:
#         continue
#     # print(flag)
#     exclude.append(flag)
# print(len(exclude), "non-induced subgraphs to exclude")

# # Condition 4 (rainbow triangle)
# for flag in TT.generate_flags(3):
#     # Make sure it has 2 edges
#     if len(flag.blocks()['edges']) != 3:
#         continue
#     # Make sure it intersects all three parts
#     if flag.blocks()['C0'] == [] or flag.blocks()['C1'] == [] or flag.blocks()['C2'] == []:
#         continue
#     # print(flag)
#     exclude.append(flag)
# print(len(exclude), "non-induced subgraphs to exclude")

# Get complete list of induced graphs to exclude
complete_excluded_list = []
for flag in exclude:
    # print(flag)
    edges = flag.blocks()['edges']
    base = edges.copy()
    n = len(flag.blocks()['C0']) + len(flag.blocks()['C1']) + len(flag.blocks()['C2'])
    extra_edges = get_more_edges(n, edges=edges)
    # print(extra_edges)
    for L in range(len(extra_edges) + _sage_const_1 ):
        for subset in itertools.combinations(extra_edges, L):
            # print(base + list(subset))
            complete_excluded_list.append(TT(n, edges=base + list(subset), C0=flag.blocks()['C0'], C1=flag.blocks()['C1'], C2=flag.blocks()['C2']))
print(len(complete_excluded_list), "induced subgraphs to exclude")

# Exclude induced
TT.exclude(complete_excluded_list)

# # Assumptions
edge_00 = TT(_sage_const_2 , edges=[[_sage_const_0 , _sage_const_1 ]], C0=[[_sage_const_0 ], [_sage_const_1 ]], C1=[], C2=[])
edge_11 = TT(_sage_const_2 , edges=[[_sage_const_0 , _sage_const_1 ]], C0=[], C1=[[_sage_const_0 ], [_sage_const_1 ]], C2=[])
edge_22 = TT(_sage_const_2 , edges=[[_sage_const_0 , _sage_const_1 ]], C0=[], C1=[], C2=[[_sage_const_0 ], [_sage_const_1 ]])
edge_01 = TT(_sage_const_2 , edges=[[_sage_const_0 , _sage_const_1 ]], C0=[[_sage_const_0 ]], C1=[[_sage_const_1 ]], C2=[])
edge_12 = TT(_sage_const_2 , edges=[[_sage_const_0 , _sage_const_1 ]], C0=[], C1=[[_sage_const_0 ]], C2=[[_sage_const_1 ]])
edge_02 = TT(_sage_const_2 , edges=[[_sage_const_0 , _sage_const_1 ]], C0=[[_sage_const_0 ]], C1=[], C2=[[_sage_const_1 ]])
point0 = TT(_sage_const_1 , edges = [], C0 = [[_sage_const_0 ]], C1 = [], C2 = [])
point1 = TT(_sage_const_1 , edges = [], C0 = [], C1 = [[_sage_const_0 ]], C2 = [])
point2 = TT(_sage_const_1 , edges = [], C0 = [], C1 = [], C2 = [[_sage_const_0 ]])
positives = [edge_12 - edge_01, edge_12 - edge_02]

# Balanced partition
positives += [point0 - _sage_const_1 /_sage_const_4 , point1 - _sage_const_1 /_sage_const_4 , point2 - _sage_const_1 /_sage_const_4 ]

positives += [edge_01 + edge_02 + edge_12 - _sage_const_1 /_sage_const_8 ]

# # # # forall i, d(v_i) <= 1/4
# positives += [1/36 - edge_00, 1/36 - edge_11, 1/36 -  edge_22]

# # # # d(v) >= 1 / 4
# positives += [edge_00 + edge_11 + edge_22 + edge_01 + edge_12 + edge_02 - 1/4]

# # # Third
# positives += [edge_12 - 1/100]

# # Missing edges
M = _sage_const_1  + TT(_sage_const_2 , edges=[], C0=[], C1=[[_sage_const_0 ]], C2=[[_sage_const_1 ]]) - _sage_const_1 

# # Bad edges
B = _sage_const_1 
B += TT(_sage_const_2 , edges=[[_sage_const_0 , _sage_const_1 ]], C0=[[_sage_const_0 ]], C1=[[_sage_const_1 ]], C2=[])
B += TT(_sage_const_2 , edges=[[_sage_const_0 , _sage_const_1 ]], C0=[[_sage_const_0 ]], C1=[], C2=[[_sage_const_1 ]])
B += TT(_sage_const_2 , edges=[[_sage_const_0 , _sage_const_1 ]], C0=[], C1=[[_sage_const_0 ], [_sage_const_1 ]], C2=[])
B += TT(_sage_const_2 , edges=[[_sage_const_0 , _sage_const_1 ]], C0=[], C1=[], C2=[[_sage_const_0 ], [_sage_const_1 ]])
B -= _sage_const_1 

# # Optimize
const = TT.blowup_construction(_sage_const_5 , _sage_const_3 , edges=[[_sage_const_1 , _sage_const_2 ]], C0=[[_sage_const_0 ]], C1=[[_sage_const_1 ]], C2=[[_sage_const_2 ]])
x = TT.optimize(B - M*_sage_const_9 /_sage_const_10 , _sage_const_5 , maximize=True, positives = positives, exact=True)
print(x)

# x = TT.optimize(B - M, 5, maximize=True, positives = positives)
# print(x)

